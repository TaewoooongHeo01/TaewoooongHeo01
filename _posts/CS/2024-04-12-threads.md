---
layout: post
title: OS - Threads & Concurrency
category: CS
excerpt: "웹 서버가 전통적인 단일 스레드 프로세스로 동작한다면, 하나의 프로세스로 한번에 하나의 클라이언트만 처리할 수 밖에 없다. 이 경우 여러 개의 클라이언트가 몰리면, 하나하나 순차적으로 처리하기 때문에 뒤에 밀린 요청은 오래 기다려야 한다. 
하나의 해결책은 요청을 받아 처리하는 과정을 프로세스로 따로 만드는 것이다. 요청이 들어오면 각 요청을 위한 프로세스를 생성하고 그에 맞게 처리하는 방식이다. 문제는 프로세스의 생성비용이 꽤 크다는 것이다. 클라이언트 요청을 위한 프로세스는 다른 프로세스들과 하는 일도 동일하다. 이러한 동일한 일에 대해 여러 개의 프로세스를 만드는 것은 비효율적이다."
---

# Thread
쓰레드는 프로세스 위에서 실행되는 흐름 단위를 말한다. 프로세스는 하나 이상의 쓰레드를 가질 수 있으며 이들은 서로 메모리를 공유한다. 

정확하게 말하자면 OS 가 프로세스를 관리하고, 그 안의 독립적인 실행 단위를 스레드 라고 한다.

만약 하나의 프로세스에 여러 개의 스레드가 존재하는 것을 멀티스레드 라고 한다.
# Motivation
멀티스레드라는 개념이 생기게 된 동기를 알아보자. 

멀티스레드는 같은 프로세스 내에 여러 개의 스레드가 존재하는 것을 말한다. 스레드는 text(코드)영역과 data(전역변수), file, signal 같은 자원들을 하나의 프로세스 내에서 공유한다. 

멀티스레드는 다중 코어를 통해 task 를 병렬적으로 처리할 수 있다. 현대의 application 들은 대부분 멀티스레드를 사용한다.

멀티스레드의 예시
- 웹 브라우저 - 이미지를 로드하는 스레드, 네트워크를 연결하는 스레드, 텍스트 표시하는 스레드가 병렬적으로 수행됨
- 워드 프로세서 - 그래픽 표시 스레드, 키 입력에 응답하는 스레드, 맞춤법 검사하는 스레드

![](https://i.imgur.com/qxMhomN.png)

웹 서버가 전통적인 단일 스레드 프로세스로 동작한다면, 하나의 프로세스로 한번에 하나의 클라이언트만 처리할 수 밖에 없다. 이 경우 여러 개의 클라이언트가 몰리면, 하나하나 순차적으로 처리하기 때문에 뒤에 밀린 요청은 오래 기다려야 한다. 

하나의 해결책은 요청을 받아 처리하는 과정을 프로세스로 따로 만드는 것이다. 요청이 들어오면 각 요청을 위한 프로세스를 생성하고 그에 맞게 처리하는 방식이다. 문제는 프로세스의 생성비용이 꽤 크다는 것이다. 클라이언트 요청을 위한 프로세스는 다른 프로세스들과 하는 일도 동일하다. 이러한 동일한 일에 대해 여러 개의 프로세스를 만드는 것은 비효율적이다.

그래서 멀티스레드 개념이 등장했다. 하나의 프로세스만 사용하고, 요청이 들어올 때 해당 프로세스 내부에서 요청을 위한 스레드를 생성하는 것이다. 서버는 클라이언트의 요청을 listen 하는 별도의 스레드를 생성한다. 이러면 단일 프로세스에 멀티 스레드 구조로 보다 효율적인 처리가 가능해진다. 

일반적으로 대부분의 운영체제에선 커널도 멀티스레드다. -> managing devices, handling interrupt 같은 작업들을 병렬적으로 처리함.

멀티스레드의 장점
- 응답성 - 특정 요청의 처리가 오래 걸리더라도, 동시에 다른 작업이 가능하다. 만약 싱글 스레드라면 하나의 처리가 끝날 때가지 아무런 동작도 할 수 없을 것이다. 
- 자원공유 - IPC 보다 하나의 프로세스 내에서 자원공유를 하는 것이 더욱 쉬움. 
- 경제성 - 프로세스 생성은 많은 자원이 소모됨. 스레드를 생성하고 거기서 context switching 하는 게 더욱 경제적임
- 규모 적응성 - multicore architecture 에서 이점이 있음. 

# Multicore_Programming
멀티스레드 프로그래밍은 멀티코어 구조에서 이점을 가질 수 있다. 작업들을 동시에 병렬적으로 처리할 수 있기 때문이다. 

물론 마냥 좋은 것만은 아니고 프로그래머가 고려해야 할 것도 있다. 
- Dividing activities
	- 작업들을 하나의 코어가 아닌, 여러 개의 코어로 잘 분산시켜야 한다. 
- Balance
	- 분할된 각 작업은 가능한 한 전체작업에 균등하게 기여해야 한다.
- Data splitting
	- 데이터를 변경하는 경우 동시에 여러 코어에서 접근하도록 하면 안됨 -> 동시성 문제
- Data dependency
	- 데이터간 의존관계가 생기면 안됨. 예를 들어 스레드A의 결과를 스레드B가 사용한다고 하면 스레드B는 스레드A의 결과가 나올 때까지 실행되지 않음 -> 멀티코어의 장점이 사라짐
- Testing and debugging
	- 테스트와 디버깅의 어려움

CPU 는 한번에 하나의 작업만 처리할 수 있다. 단일 코어의 경우 멀티스레드라 하더라도 한번에 하나의 작업만 처리할 수 있다는 특성 때문에 단지 작업이 순차적으로 진행되는 것과 같다. 
![](https://i.imgur.com/KWRjJ9G.png)

하지만 멀티코어의 경우, 여러 개의 CPU 가 존재하므로 CPU 마다 각각의 스레드를 담당해서 동시에 처리할 수 있다. 
![](https://i.imgur.com/GYF0uDN.png)

여기서 병행성과 병렬성의 차이를 이해해야 한다. 
- 병행성(Concurrency) - 하나의 CPU에서 여러 작업이 시간을 분할하여 순차적으로 실행되어, 동시에 실행되는 것처럼 보이게 하는 프로그래밍 기법. 병행성의 핵심은 **작업의 분할**이며, 여러 작업이 교대로 실행되면서 전체적인 처리 과정이 겹쳐 진행된다. 
- 병렬성(Parallelism) - 물리적으로 두 개 이상의 작업이 실제로 동시에 실행되는 것을 의미한다.

## Types of Parallelism
병렬실행은 일반적으로 두 가지 유형이 있다. 

- 데이터 병렬실행
- 태스크 병렬실행

데이터 병렬실행은 동일한 데이터의 작업을 분할해서 처리하는 것을 말한다. 예를 들어 1~N 까지 배열을 더한다고 해보자. 두 개의 코어를 사용한다고 하면, 첫번째 코어는 1~N/2 까지, 두 번째 코어는 N/2~N 까지 더하는 방식이다. 

태스크 병렬실행은 여러 개의 태스크를 동시에 처리하는 것을 말한다. 위에서 이야기한 웹 서버 예시를 들 수 있다. 

데이터 병렬실행과 태스크 병렬실행은 상호 배타적이지 않다. 둘이 같이 사용할 수도 있다. 

![](https://i.imgur.com/07lOg1a.png)

# Amdahl's Law
Amdahl's law 는 코어를 추가했을 때 얼마나 성능향상이 이루어지는 지에 대한 공식이다. 

![](https://i.imgur.com/zhxPQRH.png)
- N = 코어 수
- S = 반드시 순차적으로 실행되어야 하는 요소

예를 들어 75% 병렬실행, 25% 순차실행 요소를 가진 application 이 있다고 가정. -> 약 1.6배

![](https://i.imgur.com/8Xj1SzH.png)
여기서 알 수 있는 사실은 S(순차적 실행 요소)가 많을 수록 코어가 아무리 많아져도 성능향상이 이루어지지 않는다는 것이다. 즉, 순차실행 비율이 높을 수록 멀티코어가 의미 없어짐. 
-> 공식에 S 를 무한대로 수렴시키면 결국 1/S 가 된다.

# User Threads and Kernel Threads
스레드를 위한 지원은 user 수준과 kernel 수준 모두 제공된다.

user 스레드는 사용자 수준에서 제공되는 스레드이다. POSIX Pthreads, Windows threads, Java threads 등이 있다. 

kernel 스레드는 window, linux, macOS 를 포함한 대부분의 OS 에서 지원한다. 

어쨌든 user 스레드와 kernel 스레드는 서로 연관관계가 존재해야 한다(system call). 이러한 연관관계를 구성하는 방법은 세 가지가 있다. 
- 다대일
- 일대일
- 다대다

![](https://i.imgur.com/xxWj3JN.png)

## Many-to-One
여러 개의 user-level thread 를 하나의 kernel-level thread 에 매핑하는 방법이다. 

특징으로는 한 스레드가 봉쇄형 시스템 콜을 할 경우, 모든 프로세스가 봉쇄된다. 또한 한번에 하나의 스레드 만이 커널에 접근할 수 있기 때문에 멀티스레드가 멀티코어 시스템에서 병렬로 실행될 수 없다. 요즘엔 거의 사용하지 않는 모델이다. 

예시)
- Solaris green threads
- GNU Portable threads

![](https://i.imgur.com/K65smyG.png)

## One-to-One
각 user-level thread 마다 하나의 kernel-level thread 를 매핑하는 방식이다. 하나의 스레드가 봉쇄형 시스템 콜을 해도 나머지는 영향을 받지 않는다. 또한 다중 스레드의 병렬실행을 허용한다. 

유일한 단점은 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며 많은 수의 커널 스레드가 성능에 부담을 줄 수 있다는 것이다. 

Linux, Window 가 일대일 모델을 구현하고 있다. 
![](https://i.imgur.com/KPlaHkd.png)

## Many-to-Many
여러 개의 user-level threads 를 여러 개의 kernel-level threads 에 매핑하는 방식. 

위의 Many-to-One 의 경우, 병렬실행을 하기 어렵다는 단점이 있었다. One-to-One 의 경우 사용자 스레드 당 하나의 커널 스레드가 생성되므로, application 에서 너무 많은 사용자 스레드가 생성되지 않도록 주의해야 한다는 단점도 있었다. 

Many-to-Many 는 위와 같은 단점들을 어느정도 보완한 모델이다. 개발자는 필요한 만큼 사용자 스레드를 생성할 수 있고, 병렬실행도 잘 된다. 

![](https://i.imgur.com/KAL27Lu.png)

다대다 모델의 변형으로 two-level model 이 있다. 많은 수의 사용자 스레드를 같은 수의 커널 스레드로 연결하고 커널 스레드의 수를 제한시킬 수 있다. 

하지만 구현이 어렵고 대부분의 시스템에서 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었다. 따라서 대부분의 OS 는 One-to-One 모델을 사용한다. 

# Thread Libraries
스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리하기 위한 API 를 제공한다. 

일반적으로 스레드 라이브러리를 구현하기 위해선 두 가지 방법이 있다. 
- 온전히 user space 에서만 제공
- kernel 수준의 라이브러리 구현
	- 이 경우엔 API 호출이 곧 system call 을 호출하는 것과 같다. 

## Pthreads
Pthreads 는 스레드 라이브러리로써, user-level 또는 kernel-level 에서 제공된다.

POSIX 가 스레드 생성과 동기화를 위해 만든 펴준 API 로써, 인터페이스다. 즉, 명세만 있고 구현은 없다. 

Linux, macOS 를 포함한 많은 시스템이 Pthreads 를 구현하고 있다(window 의 경우 자체적으로 지원하진 않지만 타사가 구현한 버전을 갖다 쓸 수 있다)

C 로 정수 합을 계산하는 프로그램을 별도의 스레드로 생성하는 예시) 
![](https://i.imgur.com/VvO0ohF.png)
![](https://i.imgur.com/UnRVQbp.png)
- `#include <pthread.h>` 를 포함해야 한다. 
- `pthread_attr_init()` 으로 속성을 지정한다.
- `phtread_create()` 를 이용하여 별도의 스레드를 생성한다. 
- `runner()` 는 별도의 스레드에서 실행되고 `pthread_exit()` 을 통해 스레드를 종료한다. 
- `pthread_join` 은 스레드 생성/조인 전략을 의미한다. 
	- 스레드 생성/조인 전략이란 부모 스레드(main)가 runner 스레드가 종료될 때가지 기다렸다가 종료하는 전략이다. 

참고로 runner() 는 리턴 값이 없지만, sum 변수를 프로세스 내부에서 공유하고 있기 때문에 main 함수에 출력이 된다.

참고로 `pthread_join` 으로 여러 개의 스레드를 기다리는 방법은 for 문으로 기다리는 것임. 
![](https://i.imgur.com/MOKLJee.png)

# Implicit Threading
수많은 스레드를 가진 application 이 등장하면서 스레드 생성과 관리가 더욱 어려워졌다(위에서 언급한 문제들)

이걸 해결하는 방법은 스레드의 생성과 관리를 컴파일러와 라이브러리에게 넘겨주는 것임. 이걸 암묵적 스레딩이라고 한다.

예시)
- Thread pools (Windows API, Java)  
- Fork-join (Java)  
- OpenMP (C, C++, Fortran)  
- Grand central dispatch(MacOS and iOS)
- Intel Threading Building Blocks (C++)

## Threads Pools
위에서 예시로 든 웹 서버에서 멀티 스레드 방식은 좋은 건 맞지만 여전히 문제가 있다.
- 스레드 생성 시간소모 
- 최대 스레드 수 제한이 없음

이걸 해결할 방법 중 하나가 스레드 풀임. 스레드 풀은 스레드를 미리 만들어둠으로써 위 문제들을 해결한다. 서버는 이제 스레드를 생성하지 않고, 요청이 들어올 때마다 스레드 풀에서 스레드를 가져다 사용한다. 만약 요청이 많아서 사용할 스레드가 없다면 대기한다. 

아래와 같은 장점을 가진다. 
- 더 빠름
- 개수에 제한을 둠으로써 리소스가 고갈될 위험을 해소함
- 풀의 크기를 상황에 맞게 유동적으로 조절할 수 있음

## OpenMP
OpenMP 는 API 이고,  본질적으론 암묵적 스레딩을 위해 컴파일러에게 명령할 지시문의 집합이다. 공유 메모리 환경에서 병렬 프로그래밍을 할 수 있도록 도와준다. 

OpenMP 는 병렬로 실행될 수 있는 블록을 찾아 병렬영역(parallel regions) 라고 부른다. 개발자는 자신들의 코드 중 병렬 영역에 컴파일러 디렉티브를 삽입하고 해당 부분을 병렬로 실행하라고 지시한다. 

![](https://i.imgur.com/dThPVeP.png)
위 코드에선 순차적으로 실행되다가
{% highlight C%}
#pragma omp parallel
{% endhighlight %}
을 만나면 코어의 개수만큼 스레드를 생성한다. 이후 모든 스레드는 동시에 병렬영역을 실행한다. 

반복문을 위한 추가적인 명령도 포함한다. 
![](https://i.imgur.com/tppbfll.png)
위 경우도 
{% highlight C%}
#pragma omp parallel for
{% endhighlight %}
을 만나면 병렬로 실행할 수 있다. 예를 들어 i=0~N/2 까진 core1 이 계산하고, N/2~N 까진 core2 가 계산하는 방식이다.

# Threading Issues
멀티스레드 프로그램을 설계할 때 고려해야 할 몇 가지 문제들
## fork() and exec() system calls
fork() 를 호출한 스레드가 멀티스레드 프로세스에 포함된 경우

fork() 는 현재 프로세스를 복사하여 자식 프로세스를 생성한다. exec() 는 현재 프로세스에서 로더를 호출하여 프로세스를 메모리에 새로 올린다. 그 결과 exec() 에 의해 호출된 프로세스가 현재 프로세스를 완전히 대체한다. 따라서 fork() 이후 exec() 를 실행하면 부모 프로세스와 독립적인 새로운 프로세스를 생성하는 것과 같다.

고민해야 하는 건, fork() 하면 code, data section 을 공유한다. 이때 fork 한 child 도 스레드를 모두 상속시켜야 하나?

 이 경우 두 가지 버전이 있다. 
- 모든 스레드를 복사
- fork() 를 호출한 스레드만 복제

fork() 이후 exec() 시스템 콜을 호출하지 않으면, 프로세스에 있는 다른 스레드들 까지 모두 포함된 상태로 복제된다. 

반면 fork() 이후 exec() 를 호출한다면 새로운 프로세스가 생성된다. 새로 생성된 프로세스에는 fork() 를 호출한 스레드만 존재한다.  

## Signal handling
UNIX 시스템에서 신호는 프로세스에 특정한 이벤트가 일어났다고 알려준다. 
 
signal handler 는 신호를 처리하는데 사용된다. 신호의 처리순서는 다음과 같다. 
1. 특정 이벤트로 인해 신호가 생성
2. 생성된 신호가 프로세스에 전달
3. 전달된 신호를 처리

signal handler 는 두 가지 종류가 있다. 
- default signal handler
- user-defined signal handler

모든 신호마다 커널이 실행시키는 default signal handler 가 있다. 하지만 user-defined signal handler 에 의해 대체될 수 있다. 

신호는 항상 프로세스에 전달된다. 단일 스레드인 경우 프로세스에 바로 신호를 전달하면 되지만, 멀티 스레드의 경우 복잡해진다. 어떤 스레드에 신호를 전달해야 하는가?

다음과 같은 선택지가 있다. 
- 신호가 적용될 스레드에 전달
- 모든 스레드에 전달
- 몇몇 스레드에게만 전달
- 특정 스레드가 모든 신호를 받도록 지정

신호를 전달하는 방법은 신호의 "유형"에 따라 달라진다. 동기식 신호의 경우 해당 신호를 야기한 스레드에 전달하면 된다. 하지만 `ctrl c` 같은 비동기식 강제종료 신호의 경우 모든 스레드에 전달되어야 한다. 

## Thread Cancellation
스레드 취소는 스레드가 끝나기 전에 그것을 강제종료 시키는 것을 말한다. 예를 들어 여러 스레드가 병렬적으로 DB 를 검색하다가 결과를 찾으면 나머지 스레드를 취소시켜도 된다. 

이처럼 취소되어야 할 스레드를 `목적 스레드(target thread)` 라고 한다. 취소는 두 가지 방식으로 발생할 수 있다. 
- 비동기식 취소 - 한 스레드가 목적 스레드를 바로 강제  종료 시킴
- 지연 취소 - 주기적으로 자신 스스로가 강제종료 되어야 할 지 검사

스레드 취소를 어렵게 만드는 것은 목적 스레드들에 할당된 자원문제가 있다. 

Pthread - 스레드의 생성과 취소
![](https://i.imgur.com/o4RX4TZ.png)
Pthread 에서는 `pthread_cancel()` 을 통해 스레드를 취소할 수 있다(목적 스레드의 식별자가 파라미터로 전달). 

`pthread_cancel()` 이 호출되면 취소하라는 요청만 표시되고, 실제 취소는 대상 스레드의 설정 방식에 따라 달라진다. 

Pthread 는 세 가지 취소모드를 제공한다. 
![](https://i.imgur.com/SODugXf.png)
Off 는 **취소될 수 없는 상태**를 의미한다. 하지만 취소 요청을 계속 보류되므로 스레드는 나중에 취소를 활성화할 수 있다. 

기본 취소 유형은 `지연 취소` 이다. 스레드가 `cancellation point` 에 도달한 경우에만 취소가 발생한다. 
### References
- Operating System Concepts - Book by Abraham Silberschatz, Greg Gagne, and Peter Baer Galvin
